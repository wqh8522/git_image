# Java并发编程的艺术-笔记

## 一  并发编程的挑战

### 上下文切换

- 上下文切换：CPU是通过给每个线程分配时间片来实现多线程机制。
- 多线程不一定快：当并发执行累加操作不超过百万次时，速度会比串行执行累加操作慢。
- 如何减少上下围切换：无锁并发编程、CAS算法、使用最少线程和使用协程。
  - 无锁并发编程：多线程竞争锁是，会引起上下文切换。可以使用一些方法来避免使用锁，如：将数据的ID按照Hash算法取模分段。
  - CAS算法：JAVA的Atomic包使用CAS算法来更新数据，而不需要加锁；
  - 使用最少线程：避免创建不需要的线程；
  - 协程：单线程中使用多任务调度，并维持多个任务间的切换。

### 死锁

由于两个或两个以上的线程竞争同一资源或者由于彼此通信而造成的一种阻塞现象。

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/deadLocak.png)

避免死锁：

- 避免一个线程同时获取多个锁；
- 避免一个线程在锁内同时占用多个资源；
- 尝试使用定时锁，使用lock.tryLock（timeout）来替代内部锁机制；
- 对于数据库锁，加锁和解锁必须在一个数据库连接。

## 二  Java并发机制的底层实现原理

java代码在编译后变成Java字节码，字节码被类加载器加载到JVN里，JVM执行字节码，最终需要转化为汇编指令在CPU上执行，JAVA中使用的并发机制依赖于JVM的实现和CPU的指令。

### volatile的应用

轻量级的`synchronize`，在多处理器的开发中保证了共享变量的可见性。

- 当一个线程修改一个共享变量是，另外一个线程能读到这个修改的值
- 禁止进行指令重排序
- 无法保证**原子性**，可以保证**可见性**，在一定程度上可以保证**有序性**

### synchronized的实现原理与应用

- 对于普通同步方法，锁是当前对象的实例
- 对于静态同步方法，锁是当前类的Class对象
- 对于同步方法快，锁是`synchronized`括号里配置的对象。

> **实现原理**
>
> JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，
>
> - 代码块同步是使用monitorenter和monitorexit指令实现的

#### 对象头

synchronized用的锁是存在Java对象头里的。如果对象是数组类型，则虚拟机用3字宽存储对象头，如果是非数组类型则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，32bit

- 对象头长度：MarkWord默认存储对象HashCode、分代年龄和锁标记位。

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/%E5%AF%B9%E8%B1%A1%E5%A4%B4%E9%95%BF%E5%BA%A6.png)

- 32位JVM的MarkWord的默认存储结构

![1542717332825](C:\Users\bangsun\AppData\Roaming\Typora\typora-user-images\1542717332825.png)

- 64为JVM的MarkWord的存储结构

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/64%E4%B8%BA%E5%AF%B9%E8%B1%A1%E5%A4%B4%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png)

- MarkWord的状态变化

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/MarkWord%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96.png)

#### 锁的升级与对比

JavaSE1.6为了减少锁的释放和获得锁带来的性能消耗，引入“偏向锁”和“轻量级锁”。

锁的四种状态：级别从低到高，锁可以升级但不能降级

1. 无锁状态
2. 偏向锁状态
3. 轻量级锁状态
4. 重量级锁状态

##### 偏向锁

为了让线程获得锁的代价更低而引入了偏向锁。

获取锁：

1. 检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；
2. 若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；
3. 如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；
4. 通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；
5. 执行同步代码块

释放锁  偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：

1. 暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；
2. 撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E9%87%8A%E6%94%BE.png)

##### 轻量级锁

引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。

获取锁

1. 判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；
2. JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；
3. 判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；

释放锁  轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：

1. 取出在获取轻量级锁保存在Displaced Mark Word中的数据；
2. 用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；
3. 如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。

对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E8%8E%B7%E5%8F%96%E5%8F%8A%E8%86%A8%E8%83%80.png)

##### 锁的优缺点对比

![](https://raw.githubusercontent.com/wqh8522/my_note/pic/java/%E9%94%81%E5%AF%B9%E6%AF%94.png)